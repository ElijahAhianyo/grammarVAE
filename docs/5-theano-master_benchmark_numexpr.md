# Theano-master Benchmark Numexpr

[_Documentation generated by Documatic_](https://www.documatic.com)

<!---Documatic-section-Codebase Structure-start--->
## Codebase Structure

<!---Documatic-block-system_architecture-start--->
```mermaid
None
```
<!---Documatic-block-system_architecture-end--->

# #
<!---Documatic-section-Codebase Structure-end--->

<!---Documatic-section-Theano_master.benchmark.numexpr.gen_graph.timeit_2vector_theano-start--->
## Theano-master.benchmark.numexpr.gen_graph.timeit_2vector_theano

<!---Documatic-section-timeit_2vector_theano-start--->
<!---Documatic-block-Theano_master.benchmark.numexpr.gen_graph.timeit_2vector_theano-start--->
<details>
	<summary><code>Theano_master.benchmark.numexpr.gen_graph.timeit_2vector_theano</code> code snippet</summary>

```python
def timeit_2vector_theano(init, nb_element=1000000.0, nb_repeat=3, nb_call=int(100.0), expr='a**2 + b**2 + 2*a*b'):
    t3 = timeit.Timer('tf(av,bv)', '\nimport theano\nimport theano.tensor as T\nimport numexpr as ne\nfrom theano.tensor import exp\n%(init)s\nav=a\nbv=b\na=T.dvector()\nb=T.dvector()\ntf= theano.function([a,b],%(expr)s)\n' % locals())
    ret = t3.repeat(nb_repeat, nb_call)
    return np.asarray(ret)
```
</details>
<!---Documatic-block-Theano_master.benchmark.numexpr.gen_graph.timeit_2vector_theano-end--->
<!---Documatic-section-timeit_2vector_theano-end--->

# #
<!---Documatic-section-Theano_master.benchmark.numexpr.gen_graph.timeit_2vector_theano-end--->

<!---Documatic-section-Theano_master.benchmark.numexpr.gen_graph.timeit_2vector-start--->
## Theano-master.benchmark.numexpr.gen_graph.timeit_2vector

<!---Documatic-section-timeit_2vector-start--->
```mermaid
flowchart LR
Theano-master.benchmark.numexpr.gen_graph.timeit_2vector-->Theano-master.benchmark.numexpr.gen_graph.timeit_2vector_theano
```

### Object Calls

* Theano-master.benchmark.numexpr.gen_graph.timeit_2vector_theano

<!---Documatic-block-Theano_master.benchmark.numexpr.gen_graph.timeit_2vector-start--->
<details>
	<summary><code>Theano_master.benchmark.numexpr.gen_graph.timeit_2vector</code> code snippet</summary>

```python
def timeit_2vector(nb_element=1000000.0, nb_repeat=3, nb_call=int(100.0), expr='a**2 + b**2 + 2*a*b', do_unalign=False, do_amd=True):
    rval = dict()
    print()
    print('timeit_2vector(nb_element=%(nb_element)s,nb_repeat=%(nb_repeat)s,nb_call=%(nb_call)s, expr=%(expr)s, do_unalign=%(do_unalign)s)' % locals())
    if do_unalign:
        init = "import numpy as np; a = np.empty(%(nb_element)s, dtype='b1,f8')['f1'];b = np.empty(%(nb_element)s, dtype='b1,f8')['f1'];a[:] = np.arange(len(a));b[:] = np.arange(len(b));" % locals()
    else:
        init = 'import numpy as np; a = np.arange(%(nb_element)s);b = np.arange(%(nb_element)s)' % locals()
    t1 = timeit.Timer('%(expr)s' % locals(), 'from numpy import exp; %(init)s' % locals())
    numpy_times = np.asarray(t1.repeat(nb_repeat, nb_call))
    print('NumPy time: each time=', numpy_times, 'min_time=', numpy_times.min())
    rval['numpy'] = numpy_times
    t2 = timeit.Timer('ne.evaluate("%(expr)s")' % locals(), 'import numexpr as ne; %(init)s' % locals())
    numexpr_times = np.asarray(t2.repeat(nb_repeat, nb_call))
    rval['numexpr'] = numexpr_times
    print('Numexpr time: each time=', numexpr_times, 'min_time=', numexpr_times.min())
    theano.config.lib.amdlibm = False
    theano_times = timeit_2vector_theano(init, nb_element, nb_repeat, nb_call, expr)
    print('Theano time: each time=', theano_times, 'min_time=', theano_times.min())
    rval['theano'] = theano_times
    if do_amd:
        theano.config.lib.amdlibm = True
        theanoamd_times = timeit_2vector_theano(init, nb_element, nb_repeat, nb_call, expr)
        print('Theano+amdlibm time', theanoamd_times, theanoamd_times.min())
        rval['theano_amd'] = theanoamd_times
    print('time(NumPy) /  time(numexpr) = ', numpy_times.min() / numexpr_times.min())
    print('time(NumPy) / time(Theano)', numpy_times.min() / theano_times.min())
    print('time(numexpr) / time(Theano)', numexpr_times.min() / theano_times.min())
    if do_amd:
        print('time(NumPy) / time(Theano+amdlibm)', numpy_times.min() / theanoamd_times.min())
        print('time(numexpr) / time(Theano+amdlibm)', numexpr_times.min() / theanoamd_times.min())
    return rval
```
</details>
<!---Documatic-block-Theano_master.benchmark.numexpr.gen_graph.timeit_2vector-end--->
<!---Documatic-section-timeit_2vector-end--->

# #
<!---Documatic-section-Theano_master.benchmark.numexpr.gen_graph.timeit_2vector-end--->

<!---Documatic-section-Theano_master.benchmark.numexpr.gen_graph.exec_timeit_2vector-start--->
## Theano-master.benchmark.numexpr.gen_graph.exec_timeit_2vector

<!---Documatic-section-exec_timeit_2vector-start--->
```mermaid
flowchart LR
Theano-master.benchmark.numexpr.gen_graph.exec_timeit_2vector-->Theano-master.benchmark.numexpr.gen_graph.timeit_2vector
Theano-master.benchmark.numexpr.gen_graph.timeit_2vector-->Theano-master.benchmark.numexpr.gen_graph.timeit_2vector_theano
```

### Object Calls

* Theano-master.benchmark.numexpr.gen_graph.timeit_2vector

<!---Documatic-block-Theano_master.benchmark.numexpr.gen_graph.exec_timeit_2vector-start--->
<details>
	<summary><code>Theano_master.benchmark.numexpr.gen_graph.exec_timeit_2vector</code> code snippet</summary>

```python
def exec_timeit_2vector(expr, nb_call_scal=1, fname=None, do_unalign=False, do_amd=True):
    exp = [(1000.0, 100000), (5000.0, 50000), (10000.0, 10000), (50000.0, 5000), (100000.0, 2000), (1000000.0, 200), (10000000.0, 10)]
    exp = [(1000.0, 100000), (5000.0, 50000)]
    runtimes = []
    for (nb_e, nb_c) in exp:
        runtimes.append(timeit_2vector(nb_element=nb_e, nb_repeat=3, nb_call=nb_c * nb_call_scal, expr=expr, do_amd=do_amd))
    if do_unalign:
        runtimes_unalign = []
        for (nb_e, nb_c) in exp:
            runtimes_unalign.append(timeit_2vector(nb_element=nb_e, nb_repeat=3, nb_call=nb_c * nb_call_scal, expr=expr, do_unalign=True, do_amd=do_amd))
    print('Runtimes list = ', runtimes)
    numexpr_speedup = np.asarray([t['numpy'].min() / t['numexpr'].min() for t in runtimes], 'float32')
    print('time(NumPy) / time(numexpr)', end=' ')
    print(numexpr_speedup, numexpr_speedup.min(), numexpr_speedup.max())
    theano_speedup = np.asarray([t['numpy'].min() / t['theano'].min() for t in runtimes], 'float32')
    print('time(NumPy) / time(Theano)', end=' ')
    print(theano_speedup, theano_speedup.min(), theano_speedup.max())
    theano_numexpr_speedup = np.asarray([t['numexpr'].min() / t['theano'].min() for t in runtimes], 'float32')
    print('time(numexpr) / time(Theano)', end=' ')
    print(theano_numexpr_speedup, theano_numexpr_speedup.min(), theano_numexpr_speedup.max())
    if do_amd:
        theano_speedup2 = np.asarray([t['numpy'].min() / t['theano_amd'].min() for t in runtimes], 'float32')
        print('time(NumPy) / time(theano+amdlibm)', end=' ')
        print(theano_speedup, theano_speedup.min(), theano_speedup.max())
        theano_numexpr_speedup2 = np.asarray([t['numexpr'].min() / t['theano_amd'].min() for t in runtimes], 'float32')
        print('time(numexpr) / time(theano+amdlibm)', end=' ')
        print(theano_numexpr_speedup, theano_numexpr_speedup.min(), theano_numexpr_speedup.max())
    if 'pylab' not in globals():
        return
    nb_calls = [e[0] for e in exp]
    for cmp in range(1, len(time[0])):
        speedup = np.asarray([t[0].min() / t[cmp].min() for t in time], 'float32')
        pylab.semilogx(nb_calls, speedup, linewidth=1.0)
    if do_unalign:
        for cmp in range(1, len(time[0])):
            speedup = np.asarray([t[0].min() / t[cmp].min() for t in time_unalign], 'float32')
            pylab.semilogx(nb_calls, speedup, linewidth=1.0)
    pylab.axhline(y=1, linewidth=1.0, color='black')
    pylab.xlabel('Dimension of real valued vectors a and b')
    pylab.ylabel('Speed up vs NumPy')
    if do_unalign and do_amd:
        pylab.legend(('Numexpr', 'Theano', 'Theano(amdlibm)', 'Numexpr(unalign)', 'Theano(unalign)', 'Theano(amdlibm,unalign)'), loc='upper left')
    elif do_unalign and (not do_amd):
        pylab.legend(('Numexpr', 'Theano', 'Numexpr(unalign)', 'Theano(unalign)'), loc='upper left')
    elif not do_unalign and do_amd:
        pylab.legend(('Numexpr', 'Theano', 'Theano(amdlibm)'), loc='upper left')
    else:
        pylab.legend(('Numexpr', 'Theano'), loc='upper left')
    pylab.grid(True)
    if fname:
        pylab.savefig(fname)
        pylab.clf()
    else:
        pylab.show()
```
</details>
<!---Documatic-block-Theano_master.benchmark.numexpr.gen_graph.exec_timeit_2vector-end--->
<!---Documatic-section-exec_timeit_2vector-end--->

# #
<!---Documatic-section-Theano_master.benchmark.numexpr.gen_graph.exec_timeit_2vector-end--->

<!---Documatic-section-Theano_master.benchmark.numexpr.gen_graph.execs_timeit_2vector-start--->
## Theano-master.benchmark.numexpr.gen_graph.execs_timeit_2vector

<!---Documatic-section-execs_timeit_2vector-start--->
```mermaid
flowchart LR
Theano-master.benchmark.numexpr.gen_graph.execs_timeit_2vector-->Theano-master.benchmark.numexpr.gen_graph.timeit_2vector
Theano-master.benchmark.numexpr.gen_graph.timeit_2vector-->Theano-master.benchmark.numexpr.gen_graph.timeit_2vector_theano
```

### Object Calls

* Theano-master.benchmark.numexpr.gen_graph.timeit_2vector

<!---Documatic-block-Theano_master.benchmark.numexpr.gen_graph.execs_timeit_2vector-start--->
<details>
	<summary><code>Theano_master.benchmark.numexpr.gen_graph.execs_timeit_2vector</code> code snippet</summary>

```python
def execs_timeit_2vector(exprs, fname=None):
    exp = [(1000.0, 100000), (5000.0, 50000), (10000.0, 10000), (50000.0, 5000), (100000.0, 2000), (1000000.0, 200), (10000000.0, 10)]
    times = []
    str_expr = []
    for g_exprs in exprs:
        for expr in g_exprs:
            nb_call_scal = 1
            if isinstance(expr, tuple):
                nb_call_scal = expr[1]
                expr = expr[0]
            str_expr.append(expr)
            time = []
            for (nb_e, nb_c) in exp:
                time.append(timeit_2vector(nb_element=nb_e, nb_repeat=3, nb_call=nb_c * nb_call_scal, expr=expr, do_amd=False))
            times.append(time)
    if 'pylab' not in globals():
        return
    nb_calls = [e[0] for e in exp]
    legends = []
    colors = ['b', 'r', 'g', 'c', 'm', 'y']
    assert len(colors) >= len(times)
    fig = pylab.figure()
    for (idx, (time, expr)) in enumerate(zip(times, str_expr)):
        pylab.subplot(220 + idx + 1)
        pylab.subplots_adjust(wspace=0.25, hspace=0.25)
        speedup = [t['numpy'].min() / t['numexpr'].min() for t in time]
        pylab.semilogx(nb_calls, speedup, linewidth=1.0, color='r')
        speedup = [t['numpy'].min() / t['theano'].min() for t in time]
        pylab.semilogx(nb_calls, speedup, linewidth=1.0, color='b')
        pylab.grid(True)
        if idx == 2 or idx == 3:
            pylab.xlabel('Dimension of vectors a and b', fontsize=15)
        if idx == 0 or idx == 2:
            pylab.ylabel('Speed up vs NumPy', fontsize=15)
        pylab.axhline(y=1, linewidth=1.0, color='black')
        pylab.xlim(1000.0, 10000000.0)
        pylab.xticks([1000.0, 100000.0, 10000000.0], ['1e3', '1e5', '1e7'])
        pylab.title(expr)
    if fname:
        fig.savefig(fname)
        pylab.clf()
    else:
        pylab.show()
```
</details>
<!---Documatic-block-Theano_master.benchmark.numexpr.gen_graph.execs_timeit_2vector-end--->
<!---Documatic-section-execs_timeit_2vector-end--->

# #
<!---Documatic-section-Theano_master.benchmark.numexpr.gen_graph.execs_timeit_2vector-end--->

[_Documentation generated by Documatic_](https://www.documatic.com)